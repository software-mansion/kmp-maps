package com.swmansion.kmpmaps.core

import com.multiplatform.webview.jsbridge.IJsMessageHandler
import com.multiplatform.webview.jsbridge.JsMessage
import com.multiplatform.webview.jsbridge.WebViewJsBridge
import com.multiplatform.webview.web.WebViewNavigator
import kotlinx.serialization.Serializable
import kotlinx.serialization.json.Json

/**
 * Registers various map event handlers to the JavaScript bridge. This function facilitates
 * communication from the WebView (JavaScript) back to Kotlin, allowing the map to respond to user
 * interactions such as clicks, camera movements, and cluster rendering requests.
 *
 * @param jsBridge The bridge used for JS-Kotlin communication.
 * @param markers Current list of markers for click lookup.
 * @param circles Current list of circles for click lookup.
 * @param polygons Current list of polygons for click lookup.
 * @param polylines Current list of polylines for click lookup.
 * @param clusterSettings Settings for handling cluster clicks and custom web rendering.
 * @param onCameraMove Callback for camera position updates.
 * @param onMarkerClick Callback for marker interactions.
 * @param onCircleClick Callback for circle interactions.
 * @param onPolygonClick Callback for polygon interactions.
 * @param onPolylineClick Callback for polyline interactions.
 * @param onMapClick Callback for general map clicks.
 * @param onPOIClick Callback for Point of Interest interactions.
 * @param onMapLoaded Callback invoked when the JS map is ready.
 */
internal fun registerMapEvents(
    jsBridge: WebViewJsBridge,
    markers: List<Marker>,
    circles: List<Circle>,
    polygons: List<Polygon>,
    polylines: List<Polyline>,
    clusterSettings: ClusterSettings,
    onCameraMove: ((CameraPosition) -> Unit)?,
    onMarkerClick: ((Marker) -> Unit)?,
    onCircleClick: ((Circle) -> Unit)?,
    onPolygonClick: ((Polygon) -> Unit)?,
    onPolylineClick: ((Polyline) -> Unit)?,
    onMapClick: ((Coordinates) -> Unit)?,
    onPOIClick: ((Coordinates) -> Unit)?,
    onMapLoaded: (() -> Unit)?,
) {
    jsBridge.registerHandler("onCameraMove") { params, _ ->
        val position = Json.decodeFromString<CameraPosition>(params)
        onCameraMove?.invoke(position)
    }

    jsBridge.registerHandler("onMarkerClick") { params, _ ->
        val markerId = params
        val clickedMarker = markers.find { marker -> marker.getId() == markerId }
        clickedMarker?.let { onMarkerClick?.invoke(it) }
    }

    jsBridge.registerHandler("onMapClick") { params, _ ->
        val coords = Json.decodeFromString<Coordinates>(params)
        onMapClick?.invoke(coords)
    }

    jsBridge.registerHandler("onPOIClick") { params, _ ->
        val coords = Json.decodeFromString<Coordinates>(params)
        onPOIClick?.invoke(coords)
    }

    jsBridge.registerHandler("onMapLoaded") { _, _ -> onMapLoaded?.invoke() }

    jsBridge.registerHandler("onCircleClick") { id, _ ->
        circles.find { it.getId() == id }?.let { onCircleClick?.invoke(it) }
    }

    jsBridge.registerHandler("onPolygonClick") { id, _ ->
        polygons.find { it.getId() == id }?.let { onPolygonClick?.invoke(it) }
    }

    jsBridge.registerHandler("onPolylineClick") { id, _ ->
        polylines.find { it.getId() == id }?.let { onPolylineClick?.invoke(it) }
    }

    jsBridge.registerHandler("onClusterClick") { params, _ ->
        val cluster = Json.decodeFromString<Cluster>(params)
        clusterSettings.onClusterClick?.invoke(cluster)
    }

    jsBridge.registerHandler("renderCluster") { params, navigator ->
        val clusterJS = Json.decodeFromString<ClusterJS>(params)
        val cluster = clusterJS.toCluster()
        val html = clusterSettings.webClusterContent?.invoke(cluster)

        if (html != null) {
            val formattedHtml = html.trimIndent()
            val escapedHtmlJson = Json.encodeToString(formattedHtml)
            navigator?.evaluateJavaScript("applyClusterHtml(${clusterJS.id}, '$escapedHtmlJson')")
        }
    }
}

private fun WebViewJsBridge.registerHandler(
    methodName: String,
    handler: (String, WebViewNavigator?) -> Unit,
) {
    register(
        object : IJsMessageHandler {
            override fun methodName() = methodName

            override fun handle(
                message: JsMessage,
                navigator: WebViewNavigator?,
                callback: (String) -> Unit,
            ) {
                try {
                    handler(message.params, navigator)
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    )
}

/**
 * Internal Data Transfer Object (DTO) used for deserializing cluster data received from the
 * JavaScript Google Maps bridge.
 *
 * This class mirrors the JavaScript cluster structure, including the [id] generated by the marker
 * clusterer, which is required for further communication (e.g., custom rendering via
 * [applyClusterHtml]).
 */
@Serializable
private data class ClusterJS(
    val id: String,
    val coordinates: Coordinates,
    val size: Int,
    val items: List<Marker>,
)

/**
 * Converts a [ClusterJS] object to a [Cluster] object.
 *
 * @return A [Cluster] object containing the same data as the [ClusterJS] object.
 */
private fun ClusterJS.toCluster() = Cluster(coordinates = coordinates, size = size, items = items)
